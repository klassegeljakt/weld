use {
  std::str::FromStr,
  crate::ast::*,
  crate::syntax::program::*,
  std::collections::BTreeMap,
  lalrpop_util::ParseError,
};

grammar;

// Tokens

match { // Keywords
    "acos",
    "appender",
    "asin",
    "assert",
    "atan",
    "bool",
    "broadcast",
    "cos",
    "cosh",
    "cudf",
    "deserialize",
    "dict",
    "dictmerger",
    "erf",
    "exp",
    "f32",
    "f64",
    "for",
    "fringeiter",
    "groupmerger",
    "i16",
    "i32",
    "i64",
    "i8",
    "if",
    "iter",
    "iterate",
    "keybyiter",
    "keyexists",
    "len",
    "let",
    "log",
    "lookup",
    "macro",
    "max",
    "merge",
    "merger",
    "min",
    "nditer",
    "next",
    "nextiter",
    "optlookup",
    "pow",
    "rangeiter",
    "result",
    "select",
    "serialize",
    "simd",
    "simditer",
    "sin",
    "sinh",
    "slice",
    "sort",
    "sqrt",
    "string",
    "tan",
    "tanh",
    "tovec",
    "type",
    "u16",
    "u32",
    "u64",
    "u8",
    "unit",
    "vec",
    "vecmerger",
    "zip",
    "+",
    "-",
    "*",
    "/",
    "%",
    "|",
    "@",
    "!",
    "==",
    "=",
    "!=",
    "<",
    ">",
    "<=",
    ">=",
    "&&",
    "||",
    "&",
    "^",
    "?",
    "(",
    ")",
    "[",
    "]",
    "{",
    "}",
    ";",
    ":",
    ",",
} else { // Non-keywords
    // Decimal
    r"[0-9]+[cC]"                                                 => TI8Base10,
    r"[0-9]+si"                                                   => TI16Base10,
    r"[0-9]+[lL]"                                                 => TI64Base10,
    r"(([0-9]+\.[0-9]+([eE]-?[0-9]+)?)|([0-9]+[eE]-?[0-9]+))[fF]" => TF32Base10,
    // Binary
    r"0b[0-1]+[cC]"                                               => TI8Base2,
    r"0b[0-1]+si"                                                 => TI16Base2,
    r"0b[0-1]+[lL]"                                               => TI64Base2,
    // Hexadecimal
    r"0x[0-9a-fA-F]+[cC]"                                         => TI8Base16,
    r"0x[0-9a-fA-F]+si"                                           => TI16Base16,
    r"0x[0-9a-fA-F]+[lL]"                                         => TI64Base16,
    // Other
    r"true|false"                                                 => TBool,
    r#""[^"]""#                                                   => TString,
    r"\.\$[0-9]+"                                                 => TIndex,
} else {
    r"[0-9]+"                                                     => TI32Base10,
    r"0b[0-1]+"                                                   => TI32Base2,
    r"0x[0-9a-fA-F]+"                                             => TI32Base16,
    r"([0-9]+\.[0-9]+([eE]-?[0-9]+)?)|([0-9]+[eE]-?[0-9]+)"       => TF64Base10,
    r"[A-Za-z_][A-Za-z0-9_]*"                                     => TIdent,
}

// Macros

Vec<T>: Vec<T> = {
    <vec:(<T> ",")*> <last:T?> => match last {
        None => vec,
        Some(last) => {
            let mut vec = vec;
            vec.push(last);
            vec
        },
    },
};

Vec1<T>: Vec<T> = {
    <head:T> <tail:("," <T>)*> => {
      let mut vec = vec![head];
      vec.extend(tail);
      vec
    },
};

Vec2<T>: Vec<T> = {
    <head:(<T> "," <T>)> <tail:("," <T>)*> => {
      let mut vec = vec![head.0, head.1];
      vec.extend(tail);
      vec
    },
};

Single<T>: Vec<T> = {
    T => vec![<>]
};

Box<T>: Box<T> = T => Box::new(<>);

// Binary infix non-associative
Binary<Op, Next>: Expr = {
    <left:Box<Next>> <kind:Op> <right:Box<Next>> => Expr {
        ty: Type::Unknown,
        kind: ExprKind::BinOp {<>},
        annotations: Annotations::new(),
    },
    Next,
};

// Binary infix left-associative
BinaryLeft<Op, Next>: Expr = {
    <left:Box<BinaryLeft<Op, Next>>> <kind:Op> <right:Box<Next>> => Expr {
        ty: Type::Unknown,
        kind: ExprKind::BinOp {<>},
        annotations: Annotations::new(),
    },
    Next,
};

// Binary infix right-associative
BinaryRight<Op, Next>: Expr = {
    <left:Box<Next>> <kind:Op> <right:Box<BinaryRight<Op, Next>>> => Expr {
        ty: Type::Unknown,
        kind: ExprKind::BinOp {<>},
        annotations: Annotations::new(),
    },
    Next,
};

// Unary postfix left-associative
UnaryLeft<Op, Next>: Expr = {
    <value:Box<UnaryLeft<Op, Next>>> <kind:Op> => Expr {
        ty: Type::Unknown,
        kind: ExprKind::Unary {<>},
        annotations: Annotations::new(),
    },
    Next,
};

// Unary prefix right-associative
UnaryRight<Op, Next>: Expr = {
    <kind:Op> <value:Box<UnaryRight<Op, Next>>> => Expr {
        ty: Type::Unknown,
        kind: ExprKind::Unary {<>},
        annotations: Annotations::new(),
    },
    Next,
};

// Terminals

Ident: String = TIdent => <>.to_string();
Index: u32    = TIndex =>? u32::from_str(&<>[2..]).map_err(|_| ParseError::InvalidToken{location:0});

StringLiteral: String = TString => <>.to_string();

BoolLiteral: bool = TBool =>? bool::from_str(<>).map_err(|_| ParseError::InvalidToken{location:0});

F32Literal: f32 = TF32Base10 =>? f32::from_str(&<>[..<>.len()-1]).map_err(|_| ParseError::InvalidToken{location:0});
F64Literal: f64 = TF64Base10 =>? f64::from_str(<>).map_err(|_| ParseError::InvalidToken{location:0});

I8Literal: i8 = {
    TI8Base10 =>? i8::from_str(&<>[..<>.len()-1]).map_err(|_| ParseError::InvalidToken{location:0}),
    TI8Base2  =>? i8::from_str_radix(&<>[2..<>.len()-1], 2).map_err(|_| ParseError::InvalidToken{location:0}),
    TI8Base16 =>? i8::from_str_radix(&<>[2..<>.len()-1], 16).map_err(|_| ParseError::InvalidToken{location:0}),
};

I16Literal: i16 = {
    TI16Base10 =>? i16::from_str(&<>[..<>.len()-2]).map_err(|_| ParseError::InvalidToken{location:0}),
    TI16Base2  =>? i16::from_str_radix(&<>[2..<>.len()-2], 2).map_err(|_| ParseError::InvalidToken{location:0}),
    TI16Base16 =>? i16::from_str_radix(&<>[2..<>.len()-2], 16).map_err(|_| ParseError::InvalidToken{location:0}),
};

I32Literal: i32 = {
    TI32Base10 =>? i32::from_str(<>).map_err(|_| ParseError::InvalidToken{location:0}),
    TI32Base2  =>? i32::from_str_radix(&<>[2..], 2).map_err(|_| ParseError::InvalidToken{location:0}),
    TI32Base16 =>? i32::from_str_radix(&<>[2..], 16).map_err(|_| ParseError::InvalidToken{location:0}),
};

I64Literal: i64 = {
    TI64Base10 =>? i64::from_str(&<>[..<>.len()-1]).map_err(|_| ParseError::InvalidToken{location:0}),
    TI64Base2  =>? i64::from_str_radix(&<>[2..<>.len()-1], 2).map_err(|_| ParseError::InvalidToken{location:0}),
    TI64Base16 =>? i64::from_str_radix(&<>[2..<>.len()-1], 16).map_err(|_| ParseError::InvalidToken{location:0}),
};

// Nonterminals

pub Program: Program = <macros:Macro*> <type_aliases:TypeAlias*> <body:Expr> => Program {<>};
pub Macros = Macro*;
pub TypeAliases = TypeAlias*;

Macro: Macro = "macro" <name:Symbol> "(" <parameters:Vec<Symbol>> ")" "=" <body:Expr> ";" => Macro {<>};

TypeAlias: TypeAlias = "type" <name:Ident> "=" <ty:Type> ";" => TypeAlias {<>};

Symbol: Symbol = <Ident> => Symbol::new(<>, 0);

pub Expr = {
    LambdaExpr,
    ValueExpr,
};

LambdaExpr: Expr = {
    "||" <body:Box<ValueExpr>> => Expr {
        ty: Type::Unknown,
        kind: ExprKind::Lambda { params: Vec::new(), body },
        annotations: Annotations::new(),
    },
    "|" <params:Vec1<Parameter>> "|" <body:Box<ValueExpr>> => Expr {
        ty: Type::Unknown,
        kind: ExprKind::Lambda { params, body },
        annotations: Annotations::new(),
    },
};

Parameter: Parameter = <name:Symbol> <ty:(":" <Type>)?> => Parameter { name, ty: ty.unwrap_or(Type::Unknown) };

ValueExpr = {
    LetExpr,
    Tier01,
};

LetExpr: Expr = {
    "let" <name:Symbol> <ty:(":" <Type>)?> "=" <value:Box<Tier01>> ";" <body:Box<ValueExpr>> => Expr {
        ty: Type::Unknown,
        kind: ExprKind::Let {
            name,
            value: if let Some(ty) = ty {
              let mut value = value;
              value.ty = ty;
              value
            } else {
              value
            },
            body
        },
        annotations: Annotations::new(),
    },
};

Tier01 = BinaryLeft<Op01, Tier02>;
Tier02 = BinaryLeft<Op02, Tier03>;
Tier03 = BinaryLeft<Op03, Tier04>;
Tier04 = BinaryLeft<Op04, Tier05>;
Tier05 = BinaryLeft<Op05, Tier06>;
Tier06 = Binary<Op06, Tier07>;
Tier07 = Binary<Op07, Tier08>;
Tier08 = BinaryLeft<Op08, Tier09>;
Tier09 = BinaryLeft<Op09, Tier10>;
Tier10 = Prefix;
Tier11 = Postfix;
Tier12 = Primary;

Op01: BinOpKind = {
    "||" => BinOpKind::LogicalOr,
};

Op02: BinOpKind = {
    "&&" => BinOpKind::LogicalAnd,
};

Op03: BinOpKind = {
    "|" => BinOpKind::BitwiseOr,
};

Op04: BinOpKind = {
    "^" => BinOpKind::Xor,
};

Op05: BinOpKind = {
    "&"  => BinOpKind::BitwiseAnd,
};

Op06: BinOpKind = {
    "==" => BinOpKind::Equal,
    "!=" => BinOpKind::NotEqual,
};

Op07: BinOpKind = {
    "<"  => BinOpKind::LessThan,
    "<=" => BinOpKind::LessThanOrEqual,
    ">"  => BinOpKind::GreaterThan,
    ">=" => BinOpKind::GreaterThanOrEqual,
};

Op08: BinOpKind = {
    "+" => BinOpKind::Add,
    "-" => BinOpKind::Subtract,
};

Op09: BinOpKind = {
    "*" => BinOpKind::Multiply,
    "/" => BinOpKind::Divide,
    "%" => BinOpKind::Modulo,
};

NamedUnaryOpKind: UnaryOpKind = {
    "exp"  => UnaryOpKind::Exp,
    "sin"  => UnaryOpKind::Sin,
    "cos"  => UnaryOpKind::Cos,
    "tan"  => UnaryOpKind::Tan,
    "asin" => UnaryOpKind::ASin,
    "acos" => UnaryOpKind::ACos,
    "atan" => UnaryOpKind::ATan,
    "sinh" => UnaryOpKind::Sinh,
    "cosh" => UnaryOpKind::Cosh,
    "tanh" => UnaryOpKind::Tanh,
    "log"  => UnaryOpKind::Log,
    "erf"  => UnaryOpKind::Erf,
    "sqrt" => UnaryOpKind::Sqrt,
};

NamedBinOpKind: BinOpKind = {
    "min"  => BinOpKind::Min,
    "max"  => BinOpKind::Max,
    "pow"  => BinOpKind::Pow,
};

CommutativeBinOpKind: BinOpKind = {
    "+"   => BinOpKind::Add,
    "*"   => BinOpKind::Multiply,
    "max" => BinOpKind::Max,
    "min" => BinOpKind::Min,
};

Prefix: Expr = {
    "!" <Box<Prefix>> => Expr {
        ty: Type::Unknown,
        kind: ExprKind::Not(<>),
        annotations: Annotations::new(),
    },
    "-" <Box<Prefix>> => Expr {
        ty: Type::Unknown,
        kind: ExprKind::Negate(<>),
        annotations: Annotations::new(),
    },
    <values:Annotations?> <kind:BuilderKind> <arg:("(" <Box<ValueExpr>> ")")?> => Expr {
        ty: Type::Builder(kind, Annotations::new()),
        kind: ExprKind::NewBuilder(arg),
        annotations: Annotations::from(values),
    },
    Postfix,
};

Postfix: Expr = {
    <func:Box<Postfix>> "(" <params:Vec<Expr>> ")" => Expr {
        ty: Type::Unknown,
        kind: ExprKind::Apply {<>},
        annotations: Annotations::new(),
    },
    <expr:Box<Postfix>> <index:Index> => Expr {
        ty: Type::Unknown,
        kind: ExprKind::GetField {<>},
        annotations: Annotations::new(),
    },
    <expr:Postfix> ":" <ty:Type> => {
        let mut expr = expr;
        expr.ty = ty;
        expr
    },
    Primary,
};

Primary: Expr = {
    <values:Annotations?> <kind:PrimaryKind> => Expr {
        ty: Type::Unknown,
        kind,
        annotations: Annotations::from(values),
    },
    "(" <Expr> ")",
};

PrimaryKind: ExprKind = {
    LiteralKind                                                                                            => ExprKind::Literal(<>),
    Symbol                                                                                                 => ExprKind::Ident(<>),
    <kind:NamedBinOpKind>   "(" <left:Box<ValueExpr>> "," <right:Box<ValueExpr>> ")"                       => ExprKind::BinOp {<>},
    <kind:NamedUnaryOpKind> "(" <value:Box<ValueExpr>> ")"                                                 => ExprKind::UnaryOp {<>},
    <kind:ScalarKind>       "(" <child_expr:Box<ValueExpr>> ")"                                            => ExprKind::Cast {<>},
    "assert"      "(" <Box<ValueExpr>> ")"                                                                 => ExprKind::Assert(<>),
    "broadcast"   "(" <Box<ValueExpr>> ")"                                                                 => ExprKind::Broadcast(<>),
    "tovec"       "(" <child_expr:Box<ValueExpr>> ")"                                                      => ExprKind::ToVec {<>},
    "len"         "(" <data:Box<ValueExpr>> ")"                                                            => ExprKind::Length {<>},
    "lookup"      "(" <data:Box<ValueExpr>> "," <index:Box<ValueExpr>> ")"                                 => ExprKind::Lookup {<>},
    "optlookup"   "(" <data:Box<ValueExpr>> "," <index:Box<ValueExpr>> ")"                                 => ExprKind::OptLookup {<>},
    "keyexists"   "(" <data:Box<ValueExpr>> "," <key:Box<ValueExpr>> ")"                                   => ExprKind::KeyExists {<>},
    "slice"       "(" <data:Box<ValueExpr>> "," <index:Box<ValueExpr>> "," <size:Box<ValueExpr>> ")"       => ExprKind::Slice {<>},
    "sort"        "(" <data:Box<ValueExpr>> "," <cmpfunc:Box<LambdaExpr>> ")"                              => ExprKind::Sort {<>},
    "if"          "(" <cond:Box<ValueExpr>> "," <on_true:Box<ValueExpr>> "," <on_false:Box<ValueExpr>> ")" => ExprKind::If {<>},
    "iterate"     "(" <initial:Box<ValueExpr>> "," <update_func:Box<LambdaExpr>> ")"                       => ExprKind::Iterate {<>},
    "select"      "(" <cond:Box<ValueExpr>> "," <on_true:Box<ValueExpr>> "," <on_false:Box<ValueExpr>> ")" => ExprKind::Select {<>},
    "cudf"        "[" <sym_name:Ident> "," <return_ty:Box<Type>> "]" "(" <args:Vec<ValueExpr>> ")"         => ExprKind::CUDF {<>},
    "serialize"   "(" <Box<ValueExpr>> ")"                                                                 => ExprKind::Serialize(<>),
    "deserialize" "[" <value_ty:Box<Type>> "]" "(" <value:Box<ValueExpr>> ")"                              => ExprKind::Deserialize {<>},
    "for"         "(" <iters:Iters> "," <builder:Box<ValueExpr>> "," <func:Box<LambdaExpr>> ")"            => ExprKind::For {<>},
    "merge"       "(" <builder:Box<ValueExpr>> "," <value:Box<ValueExpr>> ")"                              => ExprKind::Merge {<>},
    "result"      "(" <builder:Box<ValueExpr>> ")"                                                         => ExprKind::Res {<>},
    "[" <elems:Vec<ValueExpr>> "]"                                                                         => ExprKind::MakeVector {<>},
    "{" <elems:Vec<ValueExpr>> "}"                                                                         => ExprKind::MakeStruct {<>},
};

Data:           Box<Expr>  = Box<ValueExpr>;
Start:   Option<Box<Expr>> = Box<ValueExpr> => Some(<>);
End:     Option<Box<Expr>> = Box<ValueExpr> => Some(<>);
Stride:  Option<Box<Expr>> = Box<ValueExpr> => Some(<>);
Strides: Option<Box<Expr>> = Box<ValueExpr> => Some(<>);
Shape:   Option<Box<Expr>> = Box<ValueExpr> => Some(<>);

ScalarIter: IterKind = "iter"       => IterKind::ScalarIter;
SimdIter:   IterKind = "simditer"   => IterKind::SimdIter;
FringeIter: IterKind = "fringeiter" => IterKind::FringeIter;
NdIter:     IterKind = "nditer"     => IterKind::NdIter;
RangeIter:  IterKind = "rangeiter"  => IterKind::RangeIter;

Iters = {
  "zip" "(" <Vec1<Iter>> ")",
  Single<Iter>,
};

Iter = {
    IterUnknown,

    IterData<ScalarIter>,
    IterData<SimdIter>,
    IterData<FringeIter>,
    IterData<NdIter>,

    IterStartEndStride<RangeIter>,

    IterDataStartEndStride<ScalarIter>,
    IterDataStartEndStride<SimdIter>,
    IterDataStartEndStride<FringeIter>,

    IterDataStartEndStrideShapeStrides<NdIter>,
};

IterUnknown: Iter = {
    <data:Data> => Iter {
        kind: IterKind::ScalarIter, data, start: None, end: None, stride: None, strides: None, shape: None
    },
};

IterData<Kind>: Iter = {
    <kind:Kind> "(" <data:Data> ")" => Iter {
        kind, data, start: None, end: None, stride: None, strides: None, shape: None,
    },
};

IterDataStartEndStride<Kind>: Iter = {
    <kind:Kind> "(" <data:Data> "," <start:Start> "," <end:End> "," <stride:Stride> ")" => Iter {
        kind, data, start, end, stride, strides: None, shape: None,
    },
};

IterDataStartEndStrideShapeStrides<Kind>: Iter = {
    <kind:Kind> "(" <data:Data> "," <start:Start> "," <end:End> "," <stride:Stride> "," <shape:Shape> "," <strides:Strides> ")" => Iter {
        kind, data, start, end, stride, shape, strides
    },
};

IterStartEndStride<Kind>: Iter = {
    <kind:Kind> "(" <start:Start> "," <end:End> "," <stride:Stride> ")" => Iter {
        kind, start, end, stride, strides: None, shape: None, data: Box::new(Expr {
            ty: Type::Unknown,
            kind: ExprKind::MakeVector { elems: Vec::new() },
            annotations: Annotations::new(),
        }),
    },
};

LiteralKind: LiteralKind = {
    BoolLiteral   => LiteralKind::BoolLiteral(<>),
    I8Literal     => LiteralKind::I8Literal(<>),
    I16Literal    => LiteralKind::I16Literal(<>),
    I32Literal    => LiteralKind::I32Literal(<>),
    I64Literal    => LiteralKind::I64Literal(<>),
    F32Literal    => LiteralKind::F32Literal(<>.to_bits()),
    F64Literal    => LiteralKind::F64Literal(<>.to_bits()),
    StringLiteral => LiteralKind::StringLiteral(<>),
};

pub Type: Type = {
    ScalarKind                                      => Type::Scalar(<>),
    <values:Annotations?> <kind:BuilderKind>        => Type::Builder(kind, Annotations::from(values)),
    "simd" "[" <ScalarKind> "]"                     => Type::Simd(<>),
    "vec"  "[" <Box<Type>> "]"                      => Type::Vector(<>),
    "dict" "[" <Box<Type>> "," <Box<Type>> "]"      => Type::Dict(<>),
    "{" <Vec<Type>> "}"                             => Type::Struct(<>),
    "||" "(" <Box<Type>> ")"                        => Type::Function(Vec::new(), <>),
    "|" <Vec1<Type>> "|" "(" <Box<Type>> ")"        => Type::Function(<>),
    Ident                                           => Type::Alias(<>, Box::new(Type::Unknown)),
    "?"                                             => Type::Unknown,
};

ScalarKind: ScalarKind = {
    "bool" => ScalarKind::Bool,
    "i8"   => ScalarKind::I8,
    "i16"  => ScalarKind::I16,
    "i32"  => ScalarKind::I32,
    "i64"  => ScalarKind::I64,
    "u8"   => ScalarKind::U8,
    "u16"  => ScalarKind::U16,
    "u32"  => ScalarKind::U32,
    "u64"  => ScalarKind::U64,
    "f32"  => ScalarKind::F32,
    "f64"  => ScalarKind::F64,
};

BuilderKind: BuilderKind = {
    "appender"    <ty:("[" <Box<Type>> "]")?>                                         => BuilderKind::Appender(<>.unwrap_or(Box::new(Type::Unknown))),
    "merger"           "[" <Box<Type>> "," <CommutativeBinOpKind> "]"                 => BuilderKind::Merger(<>),
    "dictmerger"       "[" <Box<Type>> "," <Box<Type>> "," <CommutativeBinOpKind> "]" => BuilderKind::DictMerger(<>),
    "vecmerger"        "[" <Box<Type>> "," <CommutativeBinOpKind> "]"                 => BuilderKind::VecMerger(<>),
    "groupmerger" <ty:("[" <Box<Type>> "," <Box<Type>> "]")?>                         => match ty {
        Some((ty1, ty2)) => BuilderKind::GroupMerger(ty1, ty2),
        None             => BuilderKind::GroupMerger(Box::new(Type::Unknown), Box::new(Type::Unknown)),
    },
};

Annotation: (String, String) = <id:Ident> ":" <val:AnnotationValue> => (id, val.to_string());

AnnotationValue = {
    BoolLiteral => <>.to_string(),
    I8Literal   => <>.to_string(),
    I16Literal  => <>.to_string(),
    I32Literal  => <>.to_string(),
    I64Literal  => <>.to_string(),
    F32Literal  => <>.to_string(),
    F64Literal  => <>.to_string(),
    StringLiteral,
    Ident,
};

Annotations: BTreeMap<String, String> = <values:("@" "(" <Vec<Annotation>> ")")> => values.into_iter().collect();
