use {
  std::str::FromStr,
  fxhash::hash,
  crate::ast::*,
};

grammar;

// Tokens

match { // Keywords
    "acos",
    "appender",
    "asin",
    "assert",
    "atan",
    "bool",
    "broadcast",
    "cos",
    "cosh",
    "cudf",
    "deserialize",
    "dict",
    "dictmerger",
    "erf",
    "exp",
    "f32",
    "f64",
    "for",
    "fringeiter",
    "groupmerger",
    "i16",
    "i32",
    "i64",
    "i8",
    "if",
    "iter",
    "iterate",
    "keybyiter",
    "keyexists",
    "len",
    "let",
    "log",
    "lookup",
    "macro",
    "max",
    "merge",
    "merger",
    "min",
    "nditer",
    "next",
    "nextiter",
    "optlookup",
    "pow",
    "rangeiter",
    "result",
    "select",
    "serialize",
    "simd",
    "simditer",
    "sin",
    "sinh",
    "slice",
    "sort",
    "sqrt",
    "string",
    "tan",
    "tanh",
    "tovec",
    "type",
    "u16",
    "u32",
    "u64",
    "u8",
    "unit",
    "vec",
    "vecmerger",
    "zip",
    "+",
    "-",
    "*",
    "/",
    "%",
    "|",
    "@",
    "!",
    "==",
    "=",
    "!=",
    "<",
    ">",
    "<=",
    ">=",
    "&&",
    "||",
    "&",
    "^",
    "?",
    "(",
    ")",
    "[",
    "]",
    "{",
    "}",
    ";",
    ":",
    ",",
} else { // Non-keywords
    // Decimal | Binary   | Hexadecimal
    r"(([0-9]+)|(0b[0-1]+)|(0x[0-9a-fA-F]+))[cC]"                 => TI8Literal,
    r"(([0-9]+)|(0b[0-1]+)|(0x[0-9a-fA-F]+))si"                   => TI16Literal,
    r"(([0-9]+)|(0b[0-1]+)|(0x[0-9a-fA-F]+))[lL]"                 => TI64Literal,
    r"(([0-9]+\.[0-9]+([eE]-?[0-9]+)?)|([0-9]+[eE]-?[0-9]+))[fF]" => TF32Literal,
    r"(true)|(false)"                                             => TBoolLiteral,
    r#""[^"]""#                                                   => TStringLiteral,
    r"\.\$[0-9]+"                                                 => TIndex,
} else {
    r"([0-9]+\.[0-9]+([eE]-?[0-9]+)?)|([0-9]+[eE]-?[0-9]+)"       => TF64Literal,
    r"([0-9]+)|(0b[0-1]+)|(0x[0-9a-fA-F]+)"                       => TI32Literal,
    r"[A-Za-z_][A-Za-z0-9_]*"                                     => TIdent,
}

// Macros

Vec<T>: Vec<T> = {
    <vec:(<T> ",")*> <last:T?> => match last {
        None => vec,
        Some(last) => {
            let mut vec = vec;
            vec.push(last);
            vec
        },
    },
};

NonEmptyVec<T>: Vec<T> = {
    <vec:(<T> ",")*> <last:T> => {
      let mut vec = vec;
      vec.push(last);
      vec
    },
};

Box<T>: Box<T> = T => Box::new(<>);

// Binary infix left-associative
BinaryLeft<Op, Next>: Expr = {
    <left:Box<BinaryLeft<Op, Next>>> <kind:Op> <right:Box<Next>> => Expr {
        annotations: None,
        ty: Type::Unknown,
        kind: ExprKind::BinaryOp { lhs, op, rhs },
    },
    Next,
};

// Binary infix right-associative
BinaryRight<Op, Next>: Expr = {
    <left:Box<Next>> <kind:Op> <right:Box<BinaryRight<Op, Next>>> => Expr {
        annotations: None,
        ty: Type::Unknown,
        kind: ExprKind::BinaryOp {<>},
    },
    Next,
};

// Unary postfix left-associative
UnaryLeft<Op, Next>: Expr = {
    <value:Box<UnaryLeft<Op, Next>>> <kind:Op> => Expr {
        annotations: None,
        ty: Type::Unknown,
        kind: ExprKind::Unary {<>},
    },
    Next,
};

// Unary prefix right-associative
UnaryRight<Op, Next>: Expr = {
    <kind:Op> <value:Box<UnaryRight<Op, Next>>> => Expr {
        annotations: None,
        ty: Type::Unknown,
        kind: ExprKind::Unary {<>>},
    },
    Next,
};

// Rules

pub Program: Program = <macros:Macro*> <type_aliases:TypeAlias*> <body:Expr> => Program {<>};

Macro: Macro = "macro" <name:Symbol> "(" <params:Vec<Ident>> ")" "=" <body:ValueExpr> ";" => Macro {<>};

TypeAlias: TypeAlias = "type" <id:Ident> "=" <ty:Type> ";" => TypeAlias {<>};

Ident: String = TIdent => <>.to_string();

Index: usize = TIndex => usize::from_str(&<>[2..]).unwrap();

Symbol: Symbol = <Ident> => Symbol { name: Rc::new(<>), id: hash(&<>) };

Expr: Expr = {
    LambdaExpr,
    ValueExpr,
};

LambdaExpr: Expr = {
    "||" <body:Box<ValueExpr>> => Expr {
        ty: Type::Unknown,
        kind: ExprKind::Lambda { Vec::new(), body }
        annotations: None,
    },
    "|" <params:NonEmptyVec<Parameter>> "|" <body:Box<ValueExpr>> => Expr {
        ty: Type::Unknown,
        kind: ExprKind::Lambda { ps, body },
        annotations: None,
    },
};

Parameter: Parameter = <name:Symbol> <ty:(":" <Type>)> => Parameter { name, ty: ty.unwrap_or(Type::Unknown) };

ValueExpr: Expr = {
    LetExpr,
    Tier01,
};

LetExpr: Expr = {
    "let" <name:Symbol> "=" <value:Box<Tier01>> ";" <body:Box<ValueExpr>> => Expr {
        ty: Type::Unknown,
        kind: ExprKind::Let { name, val, body },
        annotations: None,
    },
};

Tier01 = BinaryLeft<Op01, Tier02>;
Tier02 = BinaryLeft<Op02, Tier03>;
Tier03 = BinaryLeft<Op03, Tier04>;
Tier04 = BinaryLeft<Op04, Tier05>;
Tier05 = BinaryLeft<Op05, Tier06>;
Tier06 = BinaryLeft<Op06, Tier07>;
Tier07 = BinaryLeft<Op07, Tier08>;
Tier08 = BinaryLeft<Op08, Tier09>;
Tier09 = Prefix;
Tier10 = Postfix;
Tier11 = Primary;


Op01: BinOpKind = {
    "||" => BinOpKind::LogicalOr,
};

Op02: BinOpKind = {
    "&&" => BinOpKind::LogicalAnd,
};

Op03: BinOpKind = {
    "|" => BinOpKind::BitwiseOr,
    "^" => BinOpKind::Xor,
};

Op04: BinOpKind = {
    "&"  => BinOpKind::BitwiseAnd,
};

Op05: BinOpKind = {
    "==" => BinOpKind::Equal,
    "!=" => BinOpKind::NotEqual,
};

Op06: BinOpKindKind = {
    "<"  => BinOpKind::LessThan,
    ">=" => BinOpKind::LessThanEqual,
    ">"  => BinOpKind::GreaterThan,
    "<=" => BinOpKind::GreaterThanEqual,
};

Op07: BinOpKind = {
    "+" => BinOpKind::Add,
    "-" => BinOpKind::Subtract,
};

Op08: BinOpKind = {
    "*" => BinOpKind::Multiply,
    "/" => BinOpKind::Divide,
    "%" => BinOpKind::Modulo,
};

NamedUnaryOpKind: UnaryOpKind = {
    "exp"  => UnaryOpKind::Exp,
    "sin"  => UnaryOpKind::Sin,
    "cos"  => UnaryOpKind::Cos,
    "tan"  => UnaryOpKind::Tan,
    "asin" => UnaryOpKind::Asin,
    "acos" => UnaryOpKind::Acos,
    "atan" => UnaryOpKind::Atan,
    "sinh" => UnaryOpKind::Sinh,
    "cosh" => UnaryOpKind::Cosh,
    "tanh" => UnaryOpKind::Tanh,
    "log"  => UnaryOpKind::Log,
    "erf"  => UnaryOpKind::Erf,
    "sqrt" => UnaryOpKind::Sqrt,
};

NamedBinOpKind: BinOpKind = {
    "min"  => BinOpKind::Min,
    "max"  => BinOpKind::Max,
    "pow"  => BinOpKind::Pow,
};

CommutativeBinOpKind: BinOpKind = {
    "+"   => BinOpKind::Add,
    "*"   => BinOpKind::Multiply,
    "max" => BinOpKind::Max,
    "min" => BinOpKind::Min,
};

Prefix: Expr = {
    "!" <Box<Prefix>> => Expr {
        kind: ExprKind::Not(<>),
        ty: Type::Unknown,
        annotations: None
    },
    "-" <Box<Prefix>> => Expr {
        kind: ExprKind::Negate(<>),
        ty: Type::Unknown,
        annotations: None
    },
    <values: Annotations?> <kind:BuilderKind> <arg:("(" <Box<ValueExpr>> ")")?> => Expr {
        ty: Type::Builder(kind, Annotations { values.clone() }),
        kind: ExprKind::NewBuilder(arg),
        annotations: Annotations { values },
    },
    Postfix,
};

Postfix: Expr = {
    <func:Box<Postfix>> "(" <params:Vec<Expr>> ")" => Expr {
      kind: ExprKind::Apply {<>},
      ty: Type::Unknown,
      annotations: None
    },
    <expr:Box<Postfix>> <index:Index> => Expr {
      kind: ExprKind::GetField {<>},
      ty: Type::Unknown,
      annotations: None,
    },
    <expr:Postfix> ":" <ty:Type> => {
      expr.ty = ty;
      expr
    },
    Primary,
};

Primary: Expr = {
    <values:Annotations?> <kind:PrimaryKind> => Expr {
        ty: Type::Unknown,
        kind,
        Annotations { values },
    },
    "(" <Expr> ")",
};

PrimaryKind: ExprKind = {
    LiteralKind                                                                                                => ExprKind::Literal(<>),
    Ident                                                                                                      => ExprKind::Ident(<>),
    <kind:NamedBinOpKind>   "(" <left:Box<ValueExpr>> "," <right:Box<ValueExpr>> ")"                           => ExprKind::BinaryOp {<>},
    <kind:NamedUnaryOpKind> "(" <value:Box<ValueExpr>> ")"                                                     => ExprKind::UnaryOp {<>},
    <kind:ScalarKind>       "(" <child_expr:Box<ValueExpr>> ")"                                                => ExprKind::Cast {<>},
    "assert"          "(" <Box<ValueExpr>> ")"                                                                 => ExprKind::Assert(<>),
    "broadcast"       "(" <Box<ValueExpr>> ")"                                                                 => ExprKind::Broadcast(<>),
    "tovec"           "(" <child_expr:Box<ValueExpr>> ")"                                                      => ExprKind::ToVec {<>},
    "zip"             "(" <args:Vec<ValueExpr>> ")"                                                            => ExprKind::Zip {<>},
    "len"             "(" <data:Box<ValueExpr>> ")"                                                            => ExprKind::Length {<>},
    "lookup"          "(" <data:Box<ValueExpr>> "," <index:Box<ValueExpr>> ")"                                 => ExprKind::Lookup {<>},
    "optlookup"       "(" <data:Box<ValueExpr>> "," <index:Box<ValueExpr>> ")"                                 => ExprKind::OptLookup {<>},
    "keyexists"       "(" <data:Box<ValueExpr>> "," <key:Box<ValueExpr>> ")"                                   => ExprKind::KeyExists {<>},
    "slice"           "(" <data:Box<ValueExpr>> "," <index:Box<ValueExpr>> "," <size:Box<ValueExpr>> ")"       => ExprKind::Slice {<>},
    "sort"            "(" <data:Box<ValueExpr>> "," <cmpfunc:Box<LambdaExpr>> ")"                              => ExprKind::Sort {<>},
    "if"              "(" <cond:Box<ValueExpr>> "," <on_true:Box<ValueExpr>> "," <on_false:Box<ValueExpr>> ")" => ExprKind::If {<>},
    "iterate"         "(" <initial:Box<ValueExpr>> "," <update_func:Box<LambdaExpr>> ")"                       => ExprKind::Iterate {<>},
    "select"          "(" <cond:Box<ValueExpr>> "," <on_true:Box<ValueExpr>> "," <on_false:Box<ValueExpr>> ")" => ExprKind::Select {<>},
    "cudf"            "[" <sym_name:Ident> "," <return_ty:Type> "]" "(" <args:Vec<ValueExpr>> ")"              => ExprKind::CUDF {<>},
    "serialize"       "(" <Box<ValueExpr>> ")"                                                                 => ExprKind::Serialize(<>),
    "deserialize"     "[" <value_ty:Type> "]" "(" <value:Box<ValueExpr>> ")"                                   => ExprKind::Deserialize {<>},
    "for"             "(" <iters:Iter> "," <builder:Box<ValueExpr>> "," <func:Box<LambdaExpr>> ")"             => ExprKind::For {<>},
    "merge"           "(" <builder:Box<ValueExpr>> "," <value:Box<ValueExpr>> ")"                              => ExprKind::Merge {<>},
    "result"          "(" <builder:Box<ValueExpr>> ")"                                                         => ExprKind::Res {<>},
    "[" <elems:Vec<ValueExpr>> "]"                                                                             => ExprKind::MakeVector {<>},
    "{" <elems:Vec<ValueExpr>> "}"                                                                             => ExprKind::MakeStruct {<>},
};

Data:    Option<Box<Expr>> = Box<ValueExpr>  => Some(<>);
Start:   Option<Box<Expr>> = Box<ValueExpr>  => Some(<>);
End:     Option<Box<Expr>> = Box<ValueExpr>  => Some(<>);
Stride:  Option<Box<Expr>> = Box<ValueExpr>  => Some(<>);
Strides: Option<Box<Expr>> = Box<ValueExpr>  => Some(<>);
Shape:   Option<Box<Expr>> = Box<ValueExpr>  => Some(<>);

ScalarIter: IterKind = "iter"       => IterKind::ScalarIter;
SimdIter:   IterKind = "simditer"   => IterKind::SimdIter;
FringeIter: IterKind = "fringeiter" => IterKind::FringeIter;
NdIter:     IterKind = "nditer"     => IterKind::NdIter;
RangeIter:  IterKind = "rangeiter"  => IterKind::RangeIter;

IterUnknown: Iter = {
    <data:Data> => Iter {
      kind: IterKind::ScalarIter, data, start: None, end: None, stride: None, strides: None, shape: None
    },
};

IterData<Kind>: Iter = {
    <kind:Kind> "(" <data:Data> ")" => Iter {
        kind, data, start: None, end: None, stride: None, strides: None, shape: None,
    },
};

IterDataStartEndStride<Kind>: Iter = {
    <kind:Kind> "(" <data:Data> "," <start:Start> "," <end:End> "," <stride:Stride> ")" => Iter {
        kind, data, start, end, stride, strides: None, shape: None,
    },
};

IterDataStartEndStrideShapeStrides<Kind>: Iter = {
    <kind:Kind> "(" <data:Data> "," <start:Start> "," <end:End> "," <stride:Stride> "," <shape:Shape> "," <strides:Strides> ")" => Iter {
        kind, data, start, end, stride, shape, strides
    },
};

IterStartEndStride<Kind>: Iter = {
    <kind:Kind> "(" <start:Start> "," <end:End> "," <stride:Stride> ")" => Iter {
        kind, data: None, start, end, stride, strides: None, shape: None
    },
};

Iter: Iter = {
    IterUnknown,

    IterData<ScalarIter>,
    IterData<SimdIter>,
    IterData<FringeIter>,
    IterData<NdIter>,

    IterStartEndStride<RangeIter>,

    IterDataStartEndStride<ScalarIter>,
    IterDataStartEndStride<SimdIter>,
    IterDataStartEndStride<FringeIter>,

    IterDataStartEndStrideShapeStrides<NdIter>,
};

LiteralKind: LiteralKind = {
    TBoolLiteral   => LiteralKind::BoolLiteral(bool::from_str(<>).unwrap()),
    TI8Literal     => LiteralKind::I8Literal(i8::from_str(&<>[..<>.len() - 1]).unwrap()),
    TI16Literal    => LiteralKind::I16Literal(i16::from_str(&<>[..<>.len() - 2]).unwrap()),
    TI32Literal    => LiteralKind::I32Literal(i32::from_str(<>).unwrap()),
    TI64Literal    => LiteralKind::I64Literal(i64::from_str(&<>[..<>.len() - 1]).unwrap()),
    TF32Literal    => LiteralKind::F32Literal(f32::from_str(&<>[..<>.len() - 1]).unwrap()),
    TF64Literal    => LiteralKind::F64Literal(f64::from_str(<>).unwrap()),
    TStringLiteral => LiteralKind::StringLiteral(<>),
};

Type: Type = {
    ScalarKind                                      => Type::Scalar(<>),
    "simd" "[" <ScalarKind> "]"                     => Type::Simd(<>),
    "vec" "[" <Box<Type>> "]"                       => Type::Vector(<>),
    "dict" "[" <Box<Type>> "," <Box<Type>> "]"      => Type::Dict(<>),
    <values:Annotations?> <kind:BuilderKind>        => Type::Builder(kind, Annotations { values }),
    "{" <Vec<Type>> "}"                             => Type::Struct(<>),
    "||" "(" <Box<Type>> ")"                        => Type::Function(Vec::new(), <>),
    "|" <NonEmptyVec<Type>> "|" "(" <Box<Type>> ")" => Type::Function(<>},
    Ident                                           => Type::Alias(<>, Box::new(Type::Unknown)),
    "?"                                             => Type::Unknown,
};

ScalarKind: ScalarKind = {
    "bool" => ScalarKind::Bool,
    "i8"   => ScalarKind::I8,
    "i16"  => ScalarKind::I16,
    "i32"  => ScalarKind::I32,
    "i64"  => ScalarKind::I64,
    "u8"   => ScalarKind::U8,
    "u16"  => ScalarKind::U16,
    "u32"  => ScalarKind::U32,
    "u64"  => ScalarKind::U64,
    "f32"  => ScalarKind::F32,
    "f64"  => ScalarKind::F64,
};

BuilderKind: BuilderKind = {
    "appender"    "[" <Box<Type>> "]"                                            => BuilderKind::Appender(<>),
    "merger"      "[" <Box<Type>> "," <CommutativeBinOpKind> "]"                 => BuilderKind::Merger(<>),
    "dictmerger"  "[" <Box<Type>> "," <Box<Type>> "," <CommutativeBinOpKind> "]" => BuilderKind::DictMerger(<>),
    "groupmerger" "[" <Box<Type>> "," <Box<Type>> "]"                            => BuilderKind::GroupMerger(<>),
    "vecmerger"   "[" <Box<Type>> "," <CommutativeBinOpKind> "]"                 => BuilderKind::VecMerger(<>),
};

Annotation: (String, String) = <id:Ident> ":" <val:AnnotationValue> => (id, val.to_string());

AnnotationValue = {
    TBoolLiteral,
    TI8Literal,
    TI16Literal,
    TI32Literal,
    TI64Literal,
    TF32Literal,
    TF64Literal,
    TStringLiteral,
};

Annotations: BTreeMap<(String, String)> = <values:("@" "(" <Vec<Annotation>> ")")> => values.into_iter().collect();
